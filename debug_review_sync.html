<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>è°ƒè¯•å¤ä¹ çŠ¶æ€åŒæ­¥</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .result { margin: 10px 0; padding: 15px; border-radius: 5px; }
        .success { background: #d4edda; border: 1px solid #c3e6cb; }
        .error { background: #f8d7da; border: 1px solid #f5c6cb; }
        .info { background: #d1ecf1; border: 1px solid #bee5eb; }
        .warning { background: #fff3cd; border: 1px solid #ffeaa7; }
        button { padding: 10px 20px; margin: 5px; cursor: pointer; }
        pre { background: #f1f3f4; padding: 10px; border-radius: 4px; overflow-x: auto; }
    </style>
</head>
<body>
    <h1>ğŸ”§ è°ƒè¯•å¤ä¹ çŠ¶æ€åŒæ­¥é—®é¢˜</h1>
    
    <div>
        <button onclick="checkCurrentState()">ğŸ“Š æ£€æŸ¥å½“å‰çŠ¶æ€</button>
        <button onclick="simulateMarkReviewed()">âœ… æ¨¡æ‹Ÿæ ‡è®°ID=1å·²å¤ä¹ </button>
        <button onclick="testErrorBookSync()">ğŸ”„ æµ‹è¯•é”™é¢˜æœ¬åŒæ­¥é€»è¾‘</button>
        <button onclick="clearStorage()">ğŸ§¹ æ¸…é™¤localStorage</button>
    </div>

    <div id="results"></div>

    <script>
        const API_BASE = 'http://localhost:8000/api/v1';
        const TOKEN = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE3NTYxNzg4NTUsInN1YiI6IjUifQ.YSMhpQQulzOxNrzD5IQs1h15HIqX5U_OBJ7VMQezq5o';

        function addResult(content, type = 'info') {
            const container = document.getElementById('results');
            const div = document.createElement('div');
            div.className = `result ${type}`;
            div.innerHTML = content;
            container.appendChild(div);
        }

        function clearStorage() {
            localStorage.clear();
            localStorage.setItem('token', TOKEN);
            addResult('âœ… localStorageå·²æ¸…é™¤', 'success');
        }

        async function checkCurrentState() {
            const results = document.getElementById('results');
            results.innerHTML = '';
            
            addResult('ğŸ“Š æ£€æŸ¥å½“å‰çŠ¶æ€...', 'info');

            try {
                // 1. æ£€æŸ¥localStorage
                const reviewedErrors = JSON.parse(localStorage.getItem('reviewedErrors') || '[]');
                addResult(`ğŸ’¾ localStorageå·²å¤ä¹ é”™é¢˜: [${reviewedErrors.join(', ')}]`, 'info');

                // 2. è·å–APIæ•°æ®
                const response = await fetch(`${API_BASE}/student/error-book`, {
                    headers: { 'Authorization': `Bearer ${TOKEN}` }
                });
                const data = await response.json();
                const firstError = data.recent_errors[0];
                
                addResult(`ğŸ“¡ APIç¬¬ä¸€æ¡é”™é¢˜ ID=${firstError.id}, å¤ä¹ çŠ¶æ€: ${firstError.is_reviewed ? 'å·²å¤ä¹ ' : 'æœªå¤ä¹ '}`, 'info');

                // 3. æ¨¡æ‹Ÿé”™é¢˜æœ¬é¡µé¢é€»è¾‘
                const errorBookLogic = simulateErrorBookLogic([firstError], reviewedErrors);
                addResult(`ğŸ“– é”™é¢˜æœ¬é¡µé¢é€»è¾‘ç»“æœ: ID=${firstError.id} -> ${errorBookLogic[0].is_reviewed ? 'å·²å¤ä¹ ' : 'æœªå¤ä¹ '}`, errorBookLogic[0].is_reviewed ? 'success' : 'warning');

                // 4. æ¨¡æ‹Ÿé”™é¢˜è¯¦æƒ…é¡µé¢é€»è¾‘
                const errorDetailLogic = simulateErrorDetailLogic(firstError, reviewedErrors);
                addResult(`ğŸ“„ é”™é¢˜è¯¦æƒ…é¡µé¢é€»è¾‘ç»“æœ: ID=${firstError.id} -> ${errorDetailLogic.is_reviewed ? 'å·²å¤ä¹ ' : 'æœªå¤ä¹ '}`, errorDetailLogic.is_reviewed ? 'success' : 'warning');

            } catch (error) {
                addResult(`âŒ æ£€æŸ¥å¤±è´¥: ${error.message}`, 'error');
            }
        }

        function simulateErrorBookLogic(errorData, reviewedErrors) {
            // æ¨¡æ‹Ÿé”™é¢˜æœ¬é¡µé¢çš„syncLocalReviewStatusé€»è¾‘
            const result = JSON.parse(JSON.stringify(errorData)); // æ·±æ‹·è´
            
            if (reviewedErrors.length > 0) {
                result.forEach(error => {
                    if (reviewedErrors.includes(String(error.id))) {
                        error.is_reviewed = true;
                    }
                });
            }
            
            return result;
        }

        function simulateErrorDetailLogic(errorData, reviewedErrors) {
            // æ¨¡æ‹Ÿé”™é¢˜è¯¦æƒ…é¡µé¢çš„syncLocalReviewStatusé€»è¾‘
            const result = JSON.parse(JSON.stringify(errorData)); // æ·±æ‹·è´
            
            if (reviewedErrors.length > 0) {
                if (reviewedErrors.includes(String(result.id))) {
                    result.is_reviewed = true;
                }
            }
            
            return result;
        }

        function simulateMarkReviewed() {
            // æ¨¡æ‹Ÿé”™é¢˜è¯¦æƒ…é¡µé¢çš„æ ‡è®°å·²å¤ä¹ æ“ä½œ
            const errorId = '1';
            const reviewedErrors = JSON.parse(localStorage.getItem('reviewedErrors') || '[]');
            
            if (!reviewedErrors.includes(errorId)) {
                reviewedErrors.push(errorId);
                localStorage.setItem('reviewedErrors', JSON.stringify(reviewedErrors));
                addResult(`âœ… å·²æ¨¡æ‹Ÿåœ¨é”™é¢˜è¯¦æƒ…é¡µé¢æ ‡è®° ID=${errorId} ä¸ºå·²å¤ä¹ `, 'success');
                addResult(`ğŸ’¾ æ›´æ–°åçš„localStorage: [${reviewedErrors.join(', ')}]`, 'info');
                
                // è§¦å‘storageäº‹ä»¶æµ‹è¯•
                window.dispatchEvent(new StorageEvent('storage', {
                    key: 'reviewedErrors',
                    newValue: JSON.stringify(reviewedErrors),
                    oldValue: JSON.stringify(reviewedErrors.slice(0, -1))
                }));
                
            } else {
                addResult(`â„¹ï¸ ID=${errorId} å·²ç»æ ‡è®°ä¸ºå·²å¤ä¹ `, 'info');
            }
        }

        async function testErrorBookSync() {
            addResult('ğŸ”„ æµ‹è¯•é”™é¢˜æœ¬é¡µé¢åŒæ­¥é€»è¾‘...', 'info');
            
            try {
                // è·å–APIæ•°æ®
                const response = await fetch(`${API_BASE}/student/error-book`, {
                    headers: { 'Authorization': `Bearer ${TOKEN}` }
                });
                const data = await response.json();
                const errorData = data.recent_errors.slice(0, 3); // å‰3ä¸ªé”™é¢˜
                
                // è·å–localStorageæ•°æ®
                const reviewedErrors = JSON.parse(localStorage.getItem('reviewedErrors') || '[]');
                
                addResult('ğŸ” åŒæ­¥å‰åå¯¹æ¯”:', 'info');
                
                // åŒæ­¥å‰çŠ¶æ€
                const beforeSync = errorData.map(e => ({ id: e.id, is_reviewed: e.is_reviewed }));
                addResult(`åŒæ­¥å‰: ${JSON.stringify(beforeSync)}`, 'warning');
                
                // æ‰§è¡ŒåŒæ­¥é€»è¾‘
                errorData.forEach(error => {
                    if (reviewedErrors.includes(String(error.id))) {
                        error.is_reviewed = true;
                    }
                });
                
                // åŒæ­¥åçŠ¶æ€
                const afterSync = errorData.map(e => ({ id: e.id, is_reviewed: e.is_reviewed }));
                addResult(`åŒæ­¥å: ${JSON.stringify(afterSync)}`, 'success');
                
                // æ£€æŸ¥å˜åŒ–
                const hasChanges = JSON.stringify(beforeSync) !== JSON.stringify(afterSync);
                addResult(`çŠ¶æ€æ˜¯å¦æœ‰å˜åŒ–: ${hasChanges ? 'æ˜¯' : 'å¦'}`, hasChanges ? 'success' : 'warning');
                
            } catch (error) {
                addResult(`âŒ æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // ç›‘å¬storageäº‹ä»¶
        window.addEventListener('storage', function(e) {
            if (e.key === 'reviewedErrors') {
                addResult(`ğŸ“¢ æ£€æµ‹åˆ°localStorageå˜åŒ–: ${e.key} = ${e.newValue}`, 'info');
            }
        });

        // é¡µé¢åŠ è½½æ—¶è®¾ç½®token
        localStorage.setItem('token', TOKEN);
    </script>
</body>
</html>